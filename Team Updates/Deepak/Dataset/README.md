# Table_First â€” Product-Level Cleaned Sales Data

## Introduction

`Table_First` is the first structured and cleaned table generated from raw Tally-style sales register data.  
The original data contained mixed invoice-level (parent) rows and product-level (child) rows, which made direct analysis difficult.

Each row in this table represents **one product sold in one invoice**, with invoice-level details correctly propagated.

---

## Structure of Table_First (Attributes & Description)

| Column Name | Description |
|------------|------------|
| Date | Invoice date of the sale. Stored as `datetime64[ns]` with normalized time (00:00:00). |
| FIRM | Name of the client / firm to whom the product was sold. |
| FIRM_PRODUCT | Name / description of the product sold. |
| Voucher Type | Type of transaction (e.g., Sales). |
| Voucher No. | Unique invoice / voucher number generated by the system. |
| GSTIN/UIN | GST number of the client firm (if applicable). |
| Quantity | Quantity of the product sold in that invoice line. |
| Rate | Unit selling price of the product. |
| Value | Line-item total value (`Quantity Ã— Rate`). |
| brand | Derived brand name of the product (rule-based extraction). |
| category | Derived product category based on product description. |

---

## How Table_First Was Created (Step-by-Step)

### 1. Loading Raw Sales Data
- The raw Excel file (`cleaned_sales_dataset.xlsx`) was loaded using Pandas.
- This dataset contained:
  - Invoice header rows (firm-level)
  - Product detail rows

### 2. Creating a Safe Working Copy
- A copy of the original DataFrame was created to ensure:
  - No accidental modification of raw data
  - All transformations remain reproducible

### 3. Removing Unnecessary Columns
The following invoice-level or redundant columns were dropped:
- Alt. Units  
- Gross Total  
- SALE @18% LOCAL  
- CGST@9%  
- SGST@9%  
- Round Off  

### 4. Forward-Filling Invoice-Level Attributes
The following columns were forward-filled to resolve hierarchical structure:
- Date  
- Voucher Type  
- Voucher No.  
- GSTIN/UIN  

### 5. Removing Invoice Header Rows
- Rows where `FIRM_PRODUCT` was empty were removed.
- Only product-level rows were retained.

### 6. Date Normalization
- Timestamp noise was removed while retaining `datetime64[ns]` data type.

### 7. Brand Derivation
Brand was derived using rule-based keyword matching:
- HIK, EZVIZ, ECO â†’ Hikvision  
- CP â†’ CP Plus  
- DAHUA, DH- â†’ Dahua  
- DAICHI â†’ Daichi  
- IRANGE â†’ Irange  
- BEETEL â†’ Beetel  

### 8. Category Derivation
Category was derived using product description keywords:
- VDP â†’ Video Door Phone  
- CAM / DOME / BULLET â†’ Camera  
- NVR / DVR â†’ Recorder  
- CABLE / HDMI â†’ Cable / Accessories  
- POE / SWITCH â†’ Networking  

---

## Final Outcome

- Clean, flat product-level dataset
- No data loss
- Fully analysis-ready
- Suitable for dashboards, SQL databases, and downstream analytics

---
---

# Table_Second â€” Invoice-Level Cleaned Sales Data

## Introduction

`Table_Second` is the **invoice-level structured table** derived from the same raw Tally-style sales register data used for `Table_First`.

While `Table_First` focuses on **product-level transactions**, `Table_Second` captures **invoice / voucher-level information**, where:

> **Each row corresponds to one complete invoice (voucher)**  
containing consolidated financial and tax details.

This table is designed to support:
- Invoice-level analysis
- Tax reconciliation
- Client billing insights
- Safe joins with product-level data

---

## Structure of Table_Second (Attributes & Description)

| Column Name | Description |
|------------|------------|
| Date | Invoice date of the sale. Stored as `datetime64[ns]` with normalized time (00:00:00). |
| FIRM | Name of the client / firm for whom the invoice was generated. |
| Voucher No. | Unique invoice / voucher number. |
| Quantity | Total quantity recorded at the invoice level (as per source data). |
| Value | Net invoice value before tax. |
| GSTIN/UIN | GST number of the client firm (if available). |
| total_tax_amount | Total tax charged on the invoice (`CGST + SGST`). |
| Gross Total | Final invoice amount including taxes. |

> ðŸ“Œ **Grain of the table:**  
> One row = **one invoice / voucher**

---

## How Table_Second Was Created (Step-by-Step)

### 1. Loading the Cleaned Sales Dataset
- The cleaned intermediate file (`cleaned_sales_dataset.xlsx`) was loaded using Pandas.
- This dataset still contained both:
  - Invoice header rows  
  - Product detail rows  

---

### 2. Identifying Invoice-Level Rows
Invoice-level rows were identified using the condition:
- `FIRM` is present  
- `FIRM_PRODUCT` is empty  

These rows represent **voucher headers** in the original Tally-style report.

---

### 3. Selecting Invoice-Relevant Attributes
From the identified invoice rows, only invoice-level attributes were retained:

- Date  
- FIRM  
- Voucher No.  
- GSTIN/UIN  
- Quantity  
- Value  
- Gross Total  
- CGST@9%  
- SGST@9%  

This removed all product-level noise.

---

### 4. Cleaning and Normalizing Date
- Timestamp noise was removed from the `Date` column.
- The column was retained as `datetime64[ns]` for analytical compatibility.

---

### 5. Calculating Total Tax Amount
A new column `total_tax_amount` was derived as:

This provides a **single, unified tax field** per invoice.

---

### 6. Removing Redundant Tax Columns
After deriving `total_tax_amount`, the following columns were dropped to keep the table clean:
- `CGST@9%`
- `SGST@9%`
- `SALE @18% LOCAL`
- `Round Off`

---

### 7. Final Invoice-Level Table Creation
The resulting table contains:
- Exactly one row per invoice
- Clean financial totals
- No duplicated or product-level rows

---

## Relationship with Table_First

`Table_Second` can be safely joined with `Table_First` using:
Voucher No.
This enables:
- Product-to-invoice drill-down
- Invoice-wise product breakdown
- Client-level and tax-level analytics

---

## Final Outcome

- Clean, normalized invoice-level dataset
- No data loss
- Fully reproducible from raw data
- Suitable for:
  - Accounting validation
  - Tax analysis
  - BI dashboards
  - Database ingestion

---

## Why Table_Second Matters

Together with `Table_First`, this table forms a **clean analytical foundation**:

- `Table_First` â†’ *What products were sold*
- `Table_Second` â†’ *How invoices were billed*

This separation follows **good data engineering practices** and ensures scalability and clarity in analysis.

---
